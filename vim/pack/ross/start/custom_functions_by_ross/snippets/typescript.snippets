snippet zwmsg "Z-Wave Serial API command without response/callback"
	import {
		MessageOrCCLogEntry,
		ZWaveError,
		ZWaveErrorCodes,
	} from "@zwave-js/core";
	import type { Driver } from "../../driver/Driver";
	import {
		FunctionType,
		MessagePriority,
		MessageType,
	} from "../../message/Constants";
	import {
		gotDeserializationOptions,
		Message,
		MessageBaseOptions,
		MessageDeserializationOptions,
		messageTypes,
		priority,
	} from "../../message/Message";
	
	export interface $1RequestOptions extends MessageBaseOptions {
		${0:someProperty: number;}
	}
	
	@messageTypes(MessageType.Request, FunctionType.${1:Dummy})
	@priority(MessagePriority.${2:Normal})
	export class $1Request extends Message {
		public constructor(
			driver: Driver,
			options: MessageDeserializationOptions | $1RequestOptions,
		) {
			super(driver, options);
			if (gotDeserializationOptions(options)) {
				throw new ZWaveError(
					\`\${this.constructor.name}: deserialization not implemented\`,
					ZWaveErrorCodes.Deserialization_NotImplemented,
				);
			} else {
				// TODO: Populate properties from options object
				throw new Error("not implemented");
			}
		}
	
		public serialize(): Buffer {
			this.payload = Buffer.from([
				/* TODO: serialize */
			]);
	
			return super.serialize();
		}
	
		public toLogEntry(): MessageOrCCLogEntry {
			return {
				...super.toLogEntry(),
				message: {
					"some property": 1,
				},
			};
		}
	}

snippet zwmsgres "Z-Wave Serial API command with response"
	import {
		MessageOrCCLogEntry,
		ZWaveError,
		ZWaveErrorCodes,
	} from "@zwave-js/core";
	import type { Driver } from "../../driver/Driver";
	import {
		FunctionType,
		MessagePriority,
		MessageType,
	} from "../../message/Constants";
	import {
		expectedResponse,
		gotDeserializationOptions,
		Message,
		MessageBaseOptions,
		MessageDeserializationOptions,
		messageTypes,
		priority,
	} from "../../message/Message";
	import type { SuccessIndicator } from "../../message/SuccessIndicator";
	
	export interface $1RequestOptions extends MessageBaseOptions {
		${0:someProperty: number;}
	}
	
	@messageTypes(MessageType.Request, FunctionType.${1:Dummy})
	@priority(MessagePriority.${2:Normal})
	@expectedResponse(FunctionType.$1)
	export class $1Request extends Message {
		public constructor(
			driver: Driver,
			options: MessageDeserializationOptions | $1RequestOptions,
		) {
			super(driver, options);
			if (gotDeserializationOptions(options)) {
				throw new ZWaveError(
					\`\${this.constructor.name}: deserialization not implemented\`,
					ZWaveErrorCodes.Deserialization_NotImplemented,
				);
			} else {
				// TODO: Populate properties from options object
				throw new Error("not implemented");
			}
		}
	
		public serialize(): Buffer {
			this.payload = Buffer.from([
				/* TODO: serialize */
			]);
	
			return super.serialize();
		}
	
		public toLogEntry(): MessageOrCCLogEntry {
			return {
				...super.toLogEntry(),
				message: {
					"some property": 1,
				},
			};
		}
	}
	
	@messageTypes(MessageType.Response, FunctionType.$1)
	export class $1Response extends Message implements SuccessIndicator {
		public constructor(driver: Driver, options: MessageDeserializationOptions) {
			super(driver, options);
			this.wasSent = this.payload[0] !== 0;
		}
	
		isOK(): boolean {
			return this.wasSent;
		}
	
		public readonly wasSent: boolean;
	
		public toLogEntry(): MessageOrCCLogEntry {
			return {
				...super.toLogEntry(),
				message: { "was sent": this.wasSent },
			};
		}
	}

snippet zwmsgrescb "Z-Wave Serial API command with response and callback"
	import {
		MessageOrCCLogEntry,
		ZWaveError,
		ZWaveErrorCodes,
	} from "@zwave-js/core";
	import type { Driver } from "../../driver/Driver";
	import {
		FunctionType,
		MessagePriority,
		MessageType,
	} from "../../message/Constants";
	import {
		expectedCallback,
		expectedResponse,
		gotDeserializationOptions,
		Message,
		MessageBaseOptions,
		MessageDeserializationOptions,
		MessageOptions,
		messageTypes,
		priority,
	} from "../../message/Message";
	import type { SuccessIndicator } from "../../message/SuccessIndicator";
	
	@messageTypes(MessageType.Request, FunctionType.${1:Dummy})
	@priority(MessagePriority.${2:Normal})
	export class $1RequestBase extends Message {
		public constructor(driver: Driver, options: MessageOptions) {
			if (
				gotDeserializationOptions(options) &&
				(new.target as any) !== $1Callback
			) {
				return new $1Callback(driver, options);
			}
			super(driver, options);
		}
	}
	
	export interface $1RequestOptions extends MessageBaseOptions {
		${0:someProperty: number;}
	}
	
	@expectedResponse(FunctionType.$1)
	@expectedCallback(FunctionType.$1)
	export class $1Request extends $1RequestBase {
		public constructor(
			driver: Driver,
			options: MessageDeserializationOptions | $1RequestOptions,
		) {
			super(driver, options);
			if (gotDeserializationOptions(options)) {
				throw new ZWaveError(
					\`\${this.constructor.name}: deserialization not implemented\`,
					ZWaveErrorCodes.Deserialization_NotImplemented,
				);
			} else {
				// TODO: Populate properties from options object
				throw new Error("not implemented");
			}
		}
	
		public serialize(): Buffer {
			this.payload = Buffer.from([
				/* TODO: serialize */
				this.callbackId,
			]);
	
			return super.serialize();
		}
	
		public toLogEntry(): MessageOrCCLogEntry {
			return {
				...super.toLogEntry(),
				message: {
					"callback id": this.callbackId,
				},
			};
		}
	}
	
	@messageTypes(MessageType.Response, FunctionType.$1)
	export class $1Response extends Message {
		public constructor(driver: Driver, options: MessageDeserializationOptions) {
			super(driver, options);
			this.wasSent = this.payload[0] !== 0;
		}
	
		public readonly wasSent: boolean;
	
		public toLogEntry(): MessageOrCCLogEntry {
			return {
				...super.toLogEntry(),
				message: { "was sent": this.wasSent },
			};
		}
	}
	
	export class $1Callback
		extends $1RequestBase
		implements SuccessIndicator {
		public constructor(driver: Driver, options: MessageDeserializationOptions) {
			super(driver, options);
	
			this.callbackId = this.payload[0];
			this.success = this.payload[1] !== 0;
		}
	
		isOK(): boolean {
			return this.success;
		}
	
		public readonly success: boolean;
	
		public toLogEntry(): MessageOrCCLogEntry {
			return {
				...super.toLogEntry(),
				message: {
					"callback id": this.callbackId,
					success: this.success,
				},
			};
		}
	}

snippet zwmsgcb "Z-Wave Serial API command with callback"
	import {
		MessageOrCCLogEntry,
		ZWaveError,
		ZWaveErrorCodes,
	} from "@zwave-js/core";
	import type { Driver } from "../../driver/Driver";
	import {
		FunctionType,
		MessagePriority,
		MessageType,
	} from "../../message/Constants";
	import {
		expectedCallback,
		gotDeserializationOptions,
		Message,
		MessageBaseOptions,
		MessageDeserializationOptions,
		MessageOptions,
		messageTypes,
		priority,
	} from "../../message/Message";
	import type { SuccessIndicator } from "../../message/SuccessIndicator";
	
	@messageTypes(MessageType.Request, FunctionType.${1:Dummy})
	@priority(MessagePriority.${2:Normal})
	export class $1RequestBase extends Message {
		public constructor(driver: Driver, options: MessageOptions) {
			if (
				gotDeserializationOptions(options) &&
				(new.target as any) !== $1Callback
			) {
				return new $1Callback(driver, options);
			}
			super(driver, options);
		}
	}
	
	export interface $1RequestOptions extends MessageBaseOptions {
		${0:someProperty: number;}
	}
	
	@expectedCallback(FunctionType.$1)
	export class $1Request extends $1RequestBase {
		public constructor(
			driver: Driver,
			options: MessageDeserializationOptions | $1}RequestOptions,
		) {
			super(driver, options);
			if (gotDeserializationOptions(options)) {
				throw new ZWaveError(
					\`\${this.constructor.name}: deserialization not implemented\`,
					ZWaveErrorCodes.Deserialization_NotImplemented,
				);
			} else {
				// TODO: Populate properties from options object
				throw new Error("not implemented");
			}
		}
	
		public serialize(): Buffer {
			this.payload = Buffer.from([
				/* TODO: serialize */
				this.callbackId,
			]);
	
			return super.serialize();
		}
	
		public toLogEntry(): MessageOrCCLogEntry {
			return {
				...super.toLogEntry(),
				message: {
					"some property": 1,
				},
			};
		}
	}
	
	export class $1Callback
		extends $1RequestBase
		implements SuccessIndicator {
		public constructor(driver: Driver, options: MessageDeserializationOptions) {
			super(driver, options);
	
			this.callbackId = this.payload[0];
			this.success = this.payload[1] !== 0;
		}
	
		isOK(): boolean {
			return this.success;
		}
	
		public readonly success: boolean;
	
		public toLogEntry(): MessageOrCCLogEntry {
			return {
				...super.toLogEntry(),
				message: {
					"callback id": this.callbackId,
					success: this.success,
				},
			};
		}
	}

snippet zwcclog "Z-Wave Command Class log override"
	public toLogEntry(): MessageOrCCLogEntry {
		return {
			...super.toLogEntry(),
			message: { ${1:someProp}: this.$1 },
		};
	}

snippet zwcclogempty "Z-Wave Command Class log override (empty)"
	public toLogEntry(): MessageOrCCLogEntry {
		return {
			...super.toLogEntry(),
			// Hide the default payload line
			message: undefined,
		};
	}

snippet zwcc "Z-Wave Command Class implementation"
	import {
		CCCommand,
		CCCommandOptions,
		CommandClass,
		commandClass,
		expectedCCResponse,
		implementedVersion,
		CommandClassDeserializationOptions,
		gotDeserializationOptions,
	} from "./CommandClass";
	import { CommandClasses } from "@zwave-js/core";
	import type { Driver } from "../driver/Driver";
	
	// All the supported commands
	export enum ${1:Basic}Command {
		${3:// Get = 0x01}
	}
	
	@commandClass(CommandClasses.$1)
	@implementedVersion(${2:1})
	export class $1CC extends CommandClass {
		declare ccCommand: $1Command;
	}
	
	$0

snippet zwcccmd "Z-Wave CC Command"
	interface ${1:Basic}CC${2:Get}Options extends CCCommandOptions {
		someProperty: number;
	}
	
	@CCCommand($1Command.$2)
	@expectedCCResponse($1CCReport)
	export class $1CC$2 extends $1CC {
		public constructor(
			driver: Driver,
			options: CommandClassDeserializationOptions | $1CC$2Options,
		) {
			super(driver, options);
			if (gotDeserializationOptions(options)) {
				// TODO: Deserialize payload
				throw new ZWaveError(
					\`\${this.constructor.name}: deserialization not implemented\`,
					ZWaveErrorCodes.Deserialization_NotImplemented,
				);
			} else {
				// TODO: Populate properties from options object
				throw new Error("not implemented");
			}
		}
	
		public serialize(): Buffer {
			this.payload = Buffer.from([
				/* TODO: serialize */
			]);
			return super.serialize();
		}
	}
	$0

snippet zwccreport "Z-Wave CC Command (Report)"
	@CCCommand(${1:Basic}Command.$2Report)
	export class $1CC$2Report extends $1CC {
		public constructor(
			driver: Driver,
			options: CommandClassDeserializationOptions,
		) {
			super(driver, options);
			${0:// TODO: Deserialize}
		}
	}

snippet zwccemptycmd "ZWave CC Command (empty)"
	@CCCommand(${1:Basic}Command.${2:Get})
	export class $1CC$2 extends $1CC {
		public constructor(
			driver: Driver,
			options: CommandClassDeserializationOptions | CCCommandOptions,
		) {
			super(driver, options);
		}
	}

snippet zwccemptyget "ZWave CC Get Command (empty)"
	@CCCommand(${1:Basic}Command.$2Get)
	@expectedCCResponse($1CC$2Report)
	export class $1CC$2Get extends $1CC {}

snippet zwcctestresponse "ZWave test CC response implementation"
	const testResponseFor${1:Basic}$2Get: CCResponsePredicate = (
		sent: $1CC$2Get,
		received,
		isPositiveTransmitReport,
	) => {
		return received instanceof $1CC$2Report &&
			received.${3:type} === sent.$3
			? "final"
			: isPositiveTransmitReport
			? "confirmation"
			: "unexpected";
	};

snippet propread "Readonly property"
	private _${1:value}: ${2:string};
	public get $1(): $2 {
		return this._$1;
	}$0

snippet zwccprop "Z-Wave CC property"
	@ccValue() public ${1:property}: ${2:number};$0

snippet zwccapi "Z-Wave CC API"
	@API(CommandClasses.${1:Basic})
	export class $1CCAPI extends CCAPI {
		${0:// TODO: Implementation}
	}

snippet zwccsupp "Z-Wave CC supportsCommand"
	public supportsCommand(cmd: ${1:Basic}Command): Maybe<boolean> {
		switch (cmd) {
			case $1Command.Get:
			case $1Command.Set:
				return true; // This is mandatory
			// case $1Command.SomeV2Command:
			// 	return this.version >= 2;
		}
		return super.supportsCommand(cmd);
	}
	

snippet zwccassert "Z-Wave CC API assert command supported"
	this.assertSupportsCommand(
		${1:Basic}Command,
		$1Command.${2:Get},
	);
	

snippet zwccinterview "Z-Wave CC interview procedure"
	public async interview(complete: boolean = true): Promise<void> {
		const node = this.getNode()!;
		const endpoint = this.getEndpoint()!;
		const api = endpoint.commandClasses.${1:Basic}.withOptions({
			priority: MessagePriority.NodeQuery,
		});
	
		log.controller.logNode(node.id, {
			message: \`\${this.constructor.name}: doing a \${
				complete ? "complete" : "partial"
			} interview...\`,
			direction: "none",
		});
	
		log.controller.logNode(node.id, {
			message: "doing something...",
			direction: "outbound",
		});
		${0:// TODO: Implementation}
		const logMessage = \`received response for something...\`;
		log.controller.logNode(node.id, {
			message: logMessage,
			direction: "inbound",
		});
	
		// Remember that the interview is complete
		this.interviewComplete = true;
	}

snippet zwccintreq "Z-Wave CC interview requirements"
	public determineRequiredCCInterviews(): readonly CommandClasses[] {
		return [
			...super.determineRequiredCCInterviews(),
			CommandClasses.${0:Basic},
		];
	}

snippet zwccrefval "Z-Wave CC Refresh Values"
	public async refreshValues(): Promise<void> {
		const node = this.getNode()!;
		const endpoint = this.getEndpoint()!;
		const api = endpoint.commandClasses["${1:Basic}"].withOptions({
			priority: MessagePriority.NodeQuery,
		});
	
		${0:// TODO: Implementation}
	}

snippet jest "Jest test file"
	/// <reference types="jest-extended" />
	import { ${3:methodToTest} } from "./$2";
	
	describe("${1:path}/${2:moduleToTest}", () => {
		describe("$3()", () => {
			it("${4:does something}", () => {
				${0:// implementation}
			});
		});
	});

snippet zwcctest "Z-Wave CC Test"
	import { createEmptyMockDriver } from "../test/mocks";
	import type { Driver } from "../driver/Driver";
	import {
		$1CC,
		$1CCGet,
		$1CCReport,
		$1CCSet,
		$1Command,
	} from "./$1CC";
	import { getCCValueMetadata } from "./CommandClass";
	import { CommandClasses } from "@zwave-js/core";
	
	const fakeDriver = (createEmptyMockDriver() as unknown) as Driver;
	
	function buildCCBuffer(payload: Buffer): Buffer {
		return Buffer.concat([
			Buffer.from([
				CommandClasses.$1, // CC
			]),
			payload,
		]);
	}
	
	describe("lib/commandclass/${1:Basic}CC => ", () => {
		it("the Get command should serialize correctly", () => {
			const cc = new $1CCGet(fakeDriver, { nodeId: 1 });
			const expected = buildCCBuffer(
				Buffer.from([
					$1Command.Get, // CC Command
				]),
			);
			expect(cc.serialize()).toEqual(expected);
		});
	
		it("the Set command should serialize correctly", () => {
			const cc = new $1CCSet(fakeDriver, {
				nodeId: 2,
				targetValue: 55,
			});
			const expected = buildCCBuffer(
				Buffer.from([
					$1Command.Set, // CC Command
					55, // target value
				]),
			);
			expect(cc.serialize()).toEqual(expected);
		});
	
		it("the Report command (v1) should be deserialized correctly", () => {
			const ccData = buildCCBuffer(
				Buffer.from([
					$1Command.Report, // CC Command
					55, // current value
				]),
			);
			const cc = new $1CCReport(fakeDriver, { data: ccData });
	
			expect(cc.currentValue).toBe(55);
			expect(cc.targetValue).toBeUndefined();
			expect(cc.duration).toBeUndefined();
		});
	
		it("the Report command (v2) should be deserialized correctly", () => {
			const ccData = buildCCBuffer(
				Buffer.from([
					$1Command.Report, // CC Command
					55, // current value
					66, // target value
					1, // duration
				]),
			);
			const cc = new $1CCReport(fakeDriver, { data: ccData });
	
			expect(cc.currentValue).toBe(55);
			expect(cc.targetValue).toBe(66);
			expect(cc.duration!.unit).toBe("seconds");
			expect(cc.duration!.value).toBe(1);
		});
	
		it("deserializing an unsupported command should return an unspecified version of $1CC", () => {
			const serializedCC = buildCCBuffer(
				1,
				Buffer.from([255]), // not a valid command
			);
			const cc: any = new $1CC(fakeDriver, {
				data: serializedCC,
			});
			expect(cc.constructor).toBe($1CC);
		});
	
		it("the CC values should have the correct metadata", () => {
			// Readonly, 0-99
			const currentValueMeta = getCCValueMetadata(
				CommandClasses.$1,
				"currentValue",
			);
			expect(currentValueMeta).toMatchObject({
				readable: true,
				writeable: false,
				min: 0,
				max: 99,
			});
	
			// Writeable, 0-99
			const targetValueMeta = getCCValueMetadata(
				CommandClasses.$1,
				"targetValue",
			);
			expect(targetValueMeta).toMatchObject({
				readable: true,
				writeable: true,
				min: 0,
				max: 99,
			});
		});
	});
	

